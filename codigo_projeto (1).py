# -*- coding: utf-8 -*-
"""codigo_projeto.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oTUuZRfGhIf-mWEzApWg1XRREHfnCsQb
"""

!pip install pulp
import pandas as pd
import pulp as pl

# Carregar os dados
rotas_df = pd.read_csv('Rotas_editado.csv', sep=';', decimal=',')
medias_df = pd.read_csv('medias.csv', sep=';')

# Capacidades das f√°bricas (em unidades)
capacidades = {
    3403208: 17000000,
    3423909: 12500000,
    3424402: 19500000
}

# Filtrar apenas rotas CIF
rotas_cif = rotas_df[rotas_df['Incoterm'] == 'CIF'].copy()

# Converter valores de frete para float
rotas_cif['Vlr_Frete'] = rotas_cif['Vlr_Frete'].astype(str).str.replace(',', '.')
rotas_cif['Vlr_Frete'] = pd.to_numeric(rotas_cif['Vlr_Frete'], errors='coerce')

# Juntar com m√©dias e corrigir formata√ß√£o
rotas_cif = rotas_cif.merge(medias_df, on=['CO_Fabrica', 'CO_Cliente'], how='left')
rotas_cif['media_unidade'] = rotas_cif['media_unidade'].astype(str).str.replace(',', '.')
rotas_cif['media_unidade'] = pd.to_numeric(rotas_cif['media_unidade'], errors='coerce')

# Eliminar entradas inv√°lidas
rotas_cif = rotas_cif.dropna(subset=['media_unidade', 'Vlr_Frete'])

# Calcular a quantidade transportada em unidades
rotas_cif['Qtd_Unidades'] = (rotas_cif['Qtd_Transp'] * rotas_cif['media_unidade']).round().astype(int)

# Agrupar demanda total por cliente
demanda_total = rotas_cif.groupby('CO_Cliente')['Qtd_Unidades'].sum().to_dict()

# Recriar √≠ndice para vari√°veis
rotas_cif.reset_index(drop=True, inplace=True)

# Criar o problema
prob = pl.LpProblem("Otimizacao_Rotas_Transporte", pl.LpMinimize)

# Vari√°veis de decis√£o bin√°rias
rotas = rotas_cif.index.tolist()
x = pl.LpVariable.dicts("Rota", rotas, cat='Binary')

# Fun√ß√£o objetivo: minimizar o custo total
prob += pl.lpSum([rotas_cif.loc[i, 'Vlr_Frete'] * x[i] for i in rotas])

# Restri√ß√µes: capacidade das f√°bricas
for fabrica in capacidades.keys():
    prob += pl.lpSum([
        rotas_cif.loc[i, 'Qtd_Unidades'] * x[i]
        for i in rotas if rotas_cif.loc[i, 'CO_Fabrica'] == fabrica
    ]) <= capacidades[fabrica], f"Capacidade_Fabrica_{fabrica}"

# Restri√ß√µes: atender toda a demanda dos clientes
for cliente, demanda in demanda_total.items():
    prob += pl.lpSum([
        rotas_cif.loc[i, 'Qtd_Unidades'] * x[i]
        for i in rotas if rotas_cif.loc[i, 'CO_Cliente'] == cliente
    ]) >= demanda, f"Demanda_Cliente_{cliente}"

# Resolver
prob.solve()

# Verificar solu√ß√£o
if pl.LpStatus[prob.status] == 'Optimal':
    print("‚úÖ Solu√ß√£o √≥tima encontrada!")
    print(f"Custo total m√≠nimo: R$ {pl.value(prob.objective):,.2f}")

    # Extrair rotas selecionadas
    rotas_selecionadas = rotas_cif[[x[i].value() == 1 for i in rotas]].copy()

    # Remover colunas irrelevantes
    rotas_selecionadas.drop(columns=['Dt_Pedido', 'Dt_Emissao', 'Dt_Entrega', 'Mes_Base'], inplace=True, errors='ignore')

    # Salvar resultados
    rotas_selecionadas.to_csv('rotas_otimizadas.csv', index=False)
    print("üìÅ Resultados salvos em 'rotas_otimizadas.csv'")

    # Resumo por f√°brica
    print("\nüìä Resumo por f√°brica:")
    for fabrica in capacidades:
        qtd = rotas_selecionadas[rotas_selecionadas['CO_Fabrica'] == fabrica]['Qtd_Unidades'].sum()
        perc = (qtd / capacidades[fabrica]) * 100
        print(f"F√°brica {fabrica}: {qtd:,.0f} unidades ({perc:.1f}% da capacidade)")

else:
    print("‚ùå N√£o foi poss√≠vel encontrar uma solu√ß√£o √≥tima.")
    print("Status:", pl.LpStatus[prob.status])